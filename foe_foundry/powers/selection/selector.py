from __future__ import annotations

from typing import Callable, List, Set, Tuple, TypeAlias

import numpy as np
from numpy.random import Generator

from foe_foundry.features import ActionType, Feature
from foe_foundry.powers import MEDIUM_POWER, Power, PowerType
from foe_foundry.powers.creatures import CreaturePowers
from foe_foundry.powers.roles import RolePowers
from foe_foundry.powers.themed import ThemedPowers
from foe_foundry.statblocks import BaseStatblock
from foe_foundry.utils.rng import RngFactory, rng_instance

from .score import SelectionScore
from .selection import PowerSelection
from .targets import SelectionTargets

Filter: TypeAlias = Callable[[Feature], bool]


class PowerSelector:
    def __init__(
        self,
        targets: SelectionTargets,
        rng: Generator,
        stats: BaseStatblock,
        custom_filter: Callable[[Power], bool] | None = None,
        custom_weights: Callable[[Power], float] | None = None,
    ):
        self.selection = PowerSelection()
        self.targets = targets
        self.rng = rng
        self.iteration = 0
        self.custom_filter = custom_filter
        self.custom_weights = custom_weights
        self.stats = stats.copy()

        self.all_powers: List[Power] = CreaturePowers + RolePowers + ThemedPowers
        self.probabilities_raw: np.ndarray = []  # type: ignore
        self.probabilities_weighted: np.ndarray = []  # type: ignore
        self.probabilities_adjusted: np.ndarray = []  # type: ignore
        self.is_selected = []

    @property
    def is_done(self) -> bool:
        return self.selection.selected_power_level >= self.targets.power_level_target

    @property
    def score(self) -> SelectionScore:
        return self.selection.score(self.targets)

    def select_powers(self):
        while not self.is_done:
            power = self.select_next()
            if power is None:
                break
            self.selection = self.selection.with_new_power(self.stats, power)
            self.stats = power.modify_stats(self.stats)
            self.iteration += 1

        self.probabilities_adjusted = np.array(self.probabilities_adjusted)
        self.probabilities_weighted = np.array(self.probabilities_weighted)
        self.probabilities_raw = np.array(self.probabilities_raw)

    def select_next(self) -> Power | None:
        p_raw, p_weighted, p_adjusted = self.get_candidate_probabilities()
        self.probabilities_raw.append(p_raw)  # type: ignore
        self.probabilities_weighted.append(p_weighted)  # type: ignore
        self.probabilities_adjusted.append(p_adjusted)  # type: ignore

        if np.sum(p_adjusted) == 0:
            return None

        indx = self.rng.choice(a=len(self.all_powers), size=None, p=p_adjusted)
        return self.all_powers[indx]

    def get_candidate_probabilities(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Gets selection scores for each power

        Returns:
           raw_scores: raw scores coming from power.score
           weighted_scores: with the custom_weighting applied
           adjusted_scores: with feasibility multipliers applied
        """
        raw_scores = []  # raw scores coming from power.score
        weighted_scores = []  # with the custom_weighting applied
        adjusted_scores = []  # with feasibility multipliers applied

        # scores are generated via a 3 step process
        # 1. raw scores are generated by the power.score method which tells us base affinity of powers to stats
        # 2. custom weights are applied to the raw scores to give certain powers more weight
        # 3. feasibility multipliers based on constraints are applied to the weighted scores

        for power in self.all_powers:
            custom_multiplier = (
                self.custom_weights(power) if self.custom_weights else 1.0
            )

            raw_score = power.score(self.stats, relaxed_mode=custom_multiplier > 1.0)
            if raw_score <= 0:
                raw_score = -20
                weighted_score = -20
                adjusted_score = -20
            else:
                weighted_score = custom_multiplier * raw_score

                feasibility_multiplier = self.feasibility_multiplier(power)
                if feasibility_multiplier <= 0:
                    adjusted_score = -20
                else:
                    adjusted_score = feasibility_multiplier * weighted_score

            raw_scores.append(raw_score)
            weighted_scores.append(weighted_score)
            adjusted_scores.append(adjusted_score)

        raw_scores = np.array(raw_scores)
        weighted_scores = np.array(weighted_scores)
        adjusted_scores = np.array(adjusted_scores)

        return (
            _probabilities(raw_scores),
            _probabilities(weighted_scores),
            _probabilities(adjusted_scores),
        )

    def feasibility_multiplier(self, power: Power) -> float:
        score = self.score

        # check if power level is too high for remaining power budget
        if power.power_level > score.remaining_power:
            return -10

        # check if power is already selected
        if power in self.selection.selected_powers:
            return -10

        # check if a custom filter excludes the power
        if self.custom_filter is not None and not self.custom_filter(power):
            return -10

        # check if the power/feature violates any max constraints
        if not self._power_follows_max_constraints(power) or any(
            not self._feature_follows_max_constraints(f)
            for f in power.generate_features(self.stats)
        ):
            return -10

        multiplier = 1.0

        # if the creature doesn't have any high power abilities then make high power more attractive
        if power.power_level > MEDIUM_POWER and not any(
            p for p in self.selection.selected_powers if p.power_level > MEDIUM_POWER
        ):
            multiplier *= 1.25

        # if the creature doesn't yet have any Creature powers then make them more attractive
        if power.power_type == PowerType.Creature and not any(
            p
            for p in self.selection.selected_powers
            if p.power_type == PowerType.Creature
        ):
            multiplier *= 1.25

        # if the creature doesn't yet have any Theme powers then make them more attractive
        if power.power_type == PowerType.Role and not any(
            p for p in self.selection.selected_powers if p.power_type == PowerType.Role
        ):
            multiplier *= 1.25

        # if feature would cause us to go above target then make it less attractive
        # don't eliminate it entirely because it might lead to total infeasibility
        if not self._power_follows_target_goals(power) or any(
            not self._feature_follows_target_goals(f)
            for f in power.generate_features(self.stats)
        ):
            multiplier *= 0.1

        return multiplier

    def _power_follows_max_constraints(self, power: Power) -> bool:
        score = self.score
        if (
            power.power_type == PowerType.Spellcasting
            and score.spellcasting_over_max >= 0
        ):
            return False

        return True

    def _feature_follows_max_constraints(self, feature: Feature) -> bool:
        score = self.score
        if feature.action == ActionType.BonusAction and score.bonus_over_max >= 0:
            return False
        if feature.action == ActionType.Reaction and score.reactions_over_max >= 0:
            return False
        if feature.recharge and score.recharges_over_max >= 0:
            return False
        if feature.modifies_attack and score.attack_modifiers_over_max >= 0:
            return False
        if feature.uses and score.limited_uses_over_max >= 0:
            return False

        return True

    def _power_follows_target_goals(self, power: Power) -> bool:
        score = self.score
        if (
            power.power_type == PowerType.Spellcasting
            and score.spellcasting_over_target >= 0
        ):
            return False

        return True

    def _feature_follows_target_goals(self, feature: Feature) -> bool:
        score = self.score
        if feature.action == ActionType.BonusAction and score.bonus_over_target >= 0:
            return False
        if feature.action == ActionType.Reaction and score.reactions_over_target >= 0:
            return False
        if feature.recharge and score.recharges_over_target >= 0:
            return False
        if feature.modifies_attack and score.attack_modifiers_over_target >= 0:
            return False
        if feature.uses and score.limited_uses_over_target >= 0:
            return False
        return True


def _probabilities(
    scores: np.ndarray,
    temperature: float = 1.0,
    top_k: int = 50,
) -> np.ndarray:
    if np.all(scores < 0):
        return np.zeros_like(scores)

    p = np.exp(scores / temperature)
    p = p / np.sum(p)

    new_p = np.copy(p)
    # new_p[np.argsort(p)[:-top_k]] = 0
    # new_p = new_p / np.sum(new_p)
    return new_p


def select_powers(
    stats: BaseStatblock,
    rng: RngFactory | Generator,
    power_level: float,
    retries: int = 3,
    custom_filter: Callable[[Power], bool] | None = None,
    custom_weights: Callable[[Power], float] | None = None,
) -> Tuple[BaseStatblock, List[Feature], PowerSelector]:
    rng = rng_instance(rng)

    targets = SelectionTargets(
        power_level_target=power_level, power_level_max=power_level + 0.5
    )

    all_results: List[BaseStatblock] = []
    all_scores: List[float] = []
    all_powers: List[Set[Power]] = []
    selectors = []

    # try a couple of times and choose the best result
    for _ in range(retries):
        selector = PowerSelector(
            targets=targets,
            rng=rng,
            stats=stats,
            custom_filter=custom_filter,
            custom_weights=custom_weights,
        )
        selector.select_powers()
        selectors.append(selector)
        all_results.append(selector.stats)
        all_scores.append(selector.score.score)
        all_powers.append(selector.selection.selected_powers)

    indx = np.argmax(all_scores)
    new_stats = all_results[indx]
    powers = all_powers[indx]
    selector = selectors[indx]

    features = set()
    for power in powers:
        features.update(power.generate_features(new_stats))

    return new_stats, list(features), selector
