from __future__ import annotations

from typing import Callable, List, Set, Tuple, TypeAlias

import numpy as np
from numpy.random import Generator

from foe_foundry.features import ActionType, Feature
from foe_foundry.powers import MEDIUM_POWER, Power, PowerType, flags
from foe_foundry.powers.all import AllPowers
from foe_foundry.statblocks import BaseStatblock
from foe_foundry.utils.rng import RngFactory, rng_instance

from .custom import CustomPowerSelection
from .score import SelectionScore
from .selection import PowerSelection
from .settings import SelectionSettings
from .targets import SelectionTargets

Filter: TypeAlias = Callable[[Feature], bool]


class PowerSelector:
    def __init__(
        self,
        targets: SelectionTargets,
        rng: Generator,
        stats: BaseStatblock,
        custom: CustomPowerSelection | None = None,
        settings: SelectionSettings | None = None,
    ):
        self.selection = PowerSelection()
        self.targets = targets
        self.rng = rng
        self.settings = settings or SelectionSettings()
        self.iteration = 0
        self.custom = custom
        self.stats = stats.copy()

        self.all_powers: List[Power] = AllPowers.copy()
        self.probabilities_raw: np.ndarray = []  # type: ignore
        self.probabilities_weighted: np.ndarray = []  # type: ignore
        self.probabilities_adjusted: np.ndarray = []  # type: ignore
        self.is_selected = []

    @property
    def is_done(self) -> bool:
        return self.selection.selected_power_level >= self.targets.power_level_target

    @property
    def score(self) -> SelectionScore:
        return self.selection.score(self.targets)

    def select_powers(self):
        if self.custom:
            for power in self.custom.force_powers():
                # discount pre-built powers by 50% of their cost
                # their cost is already partially included in the power level of the statblock template
                self.selection = self.selection.with_new_power(
                    self.stats, power, power_level_multiplier=0.25
                )
                self.stats = power.modify_stats(self.stats)

        while not self.is_done:
            power = self.select_next()
            if power is None:
                break
            self.selection = self.selection.with_new_power(self.stats, power)
            self.stats = power.modify_stats(self.stats)
            self.iteration += 1

        self.probabilities_adjusted = np.array(self.probabilities_adjusted)
        self.probabilities_weighted = np.array(self.probabilities_weighted)
        self.probabilities_raw = np.array(self.probabilities_raw)

    def select_next(self) -> Power | None:
        p_raw, p_weighted, p_adjusted = self.get_candidate_probabilities()
        self.probabilities_raw.append(p_raw)  # type: ignore
        self.probabilities_weighted.append(p_weighted)  # type: ignore
        self.probabilities_adjusted.append(p_adjusted)  # type: ignore

        if np.sum(p_adjusted) == 0:
            return None

        indx = self.rng.choice(a=len(self.all_powers), size=None, p=p_adjusted)
        return self.all_powers[indx]

    def get_candidate_probabilities(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Gets selection scores for each power

        Returns:
           raw_scores: raw scores coming from power.score
           weighted_scores: with the custom_weighting applied
           adjusted_scores: with feasibility multipliers applied
        """
        raw_scores = []  # raw scores coming from power.score
        weighted_scores = []  # with the custom_weighting applied
        adjusted_scores = []  # with feasibility multipliers applied

        # scores are generated via a 3 step process
        # 1. raw scores are generated by the power.score method which tells us base affinity of powers to stats
        # 2. custom weights are applied to the raw scores to give certain powers more weight
        # 3. feasibility multipliers based on constraints are applied to the weighted scores

        for power in self.all_powers:
            boost = self.settings.get_boost(power)

            if self.custom is None:
                custom_multiplier = 1.0 + boost
                relaxed_mode = False
            else:
                custom_weight = self.custom.custom_weight(power)
                custom_multiplier = max(custom_weight.weight, boost)
                relaxed_mode = custom_weight.ignore_usual_requirements or boost > 0

            raw_score = power.score(self.stats, relaxed_mode=relaxed_mode)

            if raw_score <= 0:
                raw_score = -20
                weighted_score = -20
                adjusted_score = -20
            else:
                if custom_multiplier <= 0:
                    weighted_score = -20
                    adjusted_score = -20
                else:
                    weighted_score = custom_multiplier * raw_score
                    feasibility_multiplier = self.feasibility_multiplier(
                        power, check_targets=boost <= 0
                    )
                    if feasibility_multiplier <= 0:
                        adjusted_score = -20
                    else:
                        adjusted_score = feasibility_multiplier * weighted_score

            raw_scores.append(raw_score)
            weighted_scores.append(weighted_score)
            adjusted_scores.append(adjusted_score)

        raw_scores = np.array(raw_scores)
        weighted_scores = np.array(weighted_scores)
        adjusted_scores = np.array(adjusted_scores)

        return (
            self._probabilities(raw_scores),
            self._probabilities(weighted_scores),
            self._probabilities(adjusted_scores),
        )

    def feasibility_multiplier(self, power: Power, check_targets: bool = True) -> float:
        try:
            score = self.score

            # check if power level is too high for remaining power budget
            if power.power_level > score.remaining_power:
                return -10

            # check if power is already selected
            if power in self.selection.selected_powers:
                return -10

            # check if a custom filter excludes the power
            if self.custom is not None and not self.custom.filter_power(power):
                return -10

            # check if the power/feature violates any max constraints
            if not self._power_follows_max_constraints(power) or any(
                not self._feature_follows_max_constraints(f)
                for f in power.generate_features(self.stats)
            ):
                return -10

            multiplier = 1.0

            # if the creature doesn't have any high power abilities then make high power more attractive
            if power.power_level > MEDIUM_POWER and not any(
                p
                for p in self.selection.selected_powers
                if p.power_level > MEDIUM_POWER
            ):
                multiplier *= 1.25

            # if the creature doesn't yet have any Creature powers then make them more attractive
            if power.power_type == PowerType.CreatureType and not any(
                p
                for p in self.selection.selected_powers
                if p.power_type == PowerType.CreatureType
            ):
                multiplier *= 1.25

            # if the creature doesn't yet have any Theme powers then make them more attractive
            if power.power_type == PowerType.Role and not any(
                p
                for p in self.selection.selected_powers
                if p.power_type == PowerType.Role
            ):
                multiplier *= 1.25

            # if the creature already has a power of this theme then make it less attractive
            if flags.theme_flag(power.theme) in self.stats.flags:
                multiplier *= 0.5

            # if feature would cause us to go above target then make it less attractive
            # don't eliminate it entirely because it might lead to total infeasibility
            if check_targets and (
                not self._power_follows_target_goals(power)
                or any(
                    not self._feature_follows_target_goals(f)
                    for f in power.generate_features(self.stats)
                )
            ):
                multiplier *= 0.1

            return multiplier
        except ValueError:
            return -10

    def _power_follows_max_constraints(self, power: Power) -> bool:
        score = self.score
        if (
            power.power_type == PowerType.Spellcasting
            and score.spellcasting_over_max >= 0
        ):
            return False

        return True

    def _feature_follows_max_constraints(self, feature: Feature) -> bool:
        score = self.score
        if feature.action == ActionType.BonusAction and score.bonus_over_max >= 0:
            return False
        if feature.action == ActionType.Reaction and score.reactions_over_max >= 0:
            return False
        if feature.recharge and score.recharges_over_max >= 0:
            return False
        if feature.modifies_attack and score.attack_modifiers_over_max >= 0:
            return False
        if feature.uses and score.limited_uses_over_max >= 0:
            return False

        return True

    def _power_follows_target_goals(self, power: Power) -> bool:
        score = self.score
        if (
            power.power_type == PowerType.Spellcasting
            and score.spellcasting_over_target >= 0
        ):
            return False

        return True

    def _feature_follows_target_goals(self, feature: Feature) -> bool:
        score = self.score
        if feature.action == ActionType.BonusAction and score.bonus_over_target >= 0:
            return False
        if feature.action == ActionType.Reaction and score.reactions_over_target >= 0:
            return False
        if feature.recharge and score.recharges_over_target >= 0:
            return False
        if feature.modifies_attack and score.attack_modifiers_over_target >= 0:
            return False
        if feature.uses and score.limited_uses_over_target >= 0:
            return False
        return True

    def _probabilities(
        self,
        scores: np.ndarray,
    ) -> np.ndarray:
        if np.all(scores < 0):
            return np.zeros_like(scores)

        if self.settings.temperature == 0:
            p = np.zeros_like(scores)
            max_score = np.max(scores)
            max_indices = scores == max_score
            p[max_indices] = 1
            p = p / np.sum(p)
            return p

        p = np.exp(scores / self.settings.temperature)
        p = p / np.sum(p)

        sorted_indexes = np.argsort(scores)[::-1]
        top_k = min(self.settings.top_k, len(scores))
        keep_indexes = sorted_indexes[:top_k]

        new_p = np.zeros_like(p)
        new_p[keep_indexes] = p[keep_indexes]
        new_p = new_p / np.sum(new_p)

        return new_p


def select_powers(
    stats: BaseStatblock,
    rng: RngFactory | Generator,
    settings: SelectionSettings | None = None,
    custom: CustomPowerSelection | None = None,
) -> Tuple[BaseStatblock, List[Feature], PowerSelector]:
    if settings is None:
        settings = SelectionSettings()

    rng = rng_instance(rng)

    power_level_target = settings.power_multiplier * stats.recommended_powers
    power_level_max = power_level_target + 0.5

    targets = SelectionTargets(
        power_level_target=power_level_target, power_level_max=power_level_max
    )

    all_results: List[BaseStatblock] = []
    all_scores: List[float] = []
    all_powers: List[Set[Power]] = []
    selectors = []

    # try a couple of times and choose the best result
    for _ in range(settings.retries):
        selector = PowerSelector(
            targets=targets, rng=rng, stats=stats, custom=custom, settings=settings
        )
        selector.select_powers()
        selectors.append(selector)
        all_results.append(selector.stats)
        all_scores.append(selector.score.score)
        all_powers.append(selector.selection.selected_powers)

    indx = np.argmax(all_scores)
    new_stats = all_results[indx]
    powers = all_powers[indx]
    selector = selectors[indx]

    features = set()
    for power in powers:
        features.update(power.generate_features(new_stats))

    return new_stats, list(features), selector
